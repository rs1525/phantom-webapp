<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phantom Memecoins Bot</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <script src="https://unpkg.com/@phantom-labs/sdk@latest/dist/index.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #1c1c1e;
            color: white;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            text-align: center;
        }
        .button {
            background-color: #512da8;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 12px;
            font-size: 16px;
            margin: 10px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .button:hover {
            background-color: #673ab7;
        }
        .status {
            margin: 20px 0;
            padding: 15px;
            border-radius: 8px;
            background-color: #2c2c2e;
        }
        .token-list {
            text-align: left;
            margin-top: 20px;
        }
        .token-item {
            background-color: #2c2c2e;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            position: relative;
        }
        .token-item .price-change {
            position: absolute;
            right: 15px;
            top: 15px;
            font-weight: bold;
        }
        .token-item .price-change.positive {
            color: #4caf50;
        }
        .token-item .price-change.negative {
            color: #f44336;
        }
        .token-item .details {
            margin-top: 10px;
            font-size: 14px;
            color: #888;
        }
        .token-item .analysis {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #444;
        }
        .token-item .buy-signal {
            color: #4caf50;
            font-weight: bold;
        }
        .token-item .sell-signal {
            color: #f44336;
            font-weight: bold;
        }
        .error {
            color: #ff4444;
            margin: 10px 0;
        }
        .loading {
            display: none;
            margin: 20px 0;
        }
        .wallet-status {
            background: #2c2c2e;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
        }
        .trade-history {
            margin-top: 20px;
            text-align: left;
        }
        .trade-item {
            background: #2c2c2e;
            padding: 10px;
            margin: 5px 0;
            border-radius: 8px;
            font-size: 14px;
        }
        .profit {
            color: #4caf50;
        }
        .loss {
            color: #f44336;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Phantom Memecoins Bot</h1>
        <div id="walletStatus" class="wallet-status">No conectado</div>
        <button id="connectBtn" class="button">Conectar Phantom</button>
        <div id="status" class="status">Esperando conexión...</div>
        <div id="error" class="error"></div>
        <div id="loading" class="loading">Analizando memecoins...</div>
        <div id="tokenList" class="token-list"></div>
        <div id="tradeHistory" class="trade-history"></div>
    </div>

    <script>
        let tg = window.Telegram.WebApp;
        let phantom;
        let publicKey;
        let activeTrading = false;
        let currentTrade = null;
        
        // Configuración de trading
        const PROFIT_TARGET = 5; // 5% de ganancia
        const STOP_LOSS = -3; // 3% de pérdida
        const MIN_VOLUME = 50000; // Volumen mínimo en USD
        const MIN_AGE_HOURS = 24; // Edad mínima del token en horas

        // Inicializar la Web App y Phantom
        tg.expand();
        tg.ready();

        async function initPhantom() {
            try {
                phantom = new PhantomWallet();
                await phantom.init();
                return true;
            } catch (error) {
                showError('Error inicializando Phantom: ' + error.message);
                return false;
            }
        }

        async function connectPhantom() {
            try {
                if (!await initPhantom()) return;

                const connected = await phantom.connect();
                if (!connected) {
                    showError('No se pudo conectar con Phantom');
                    return;
                }

                publicKey = phantom.publicKey.toString();
                document.getElementById('walletStatus').textContent = `Conectado: ${publicKey.slice(0, 4)}...${publicKey.slice(-4)}`;
                document.getElementById('connectBtn').style.display = 'none';
                startTradingBot();
            } catch (err) {
                showError(`Error de conexión: ${err.message}`);
            }
        }

        function showError(message) {
            document.getElementById('error').textContent = message;
            setTimeout(() => {
                document.getElementById('error').textContent = '';
            }, 5000);
        }

        async function getTrendingMemecoins() {
            try {
                document.getElementById('loading').style.display = 'block';
                
                // Obtener trending tokens directamente de Phantom
                const trendingTokens = await phantom.getTrendingTokens();
                
                // Filtrar solo memecoins
                const memecoins = trendingTokens.filter(token => {
                    const name = token.name.toLowerCase();
                    const symbol = token.symbol.toLowerCase();
                    return isMemeToken(name) || isMemeToken(symbol);
                });

                return memecoins;
            } catch (error) {
                showError(`Error obteniendo memecoins: ${error.message}`);
                return [];
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }

        function isMemeToken(text) {
            const memeKeywords = [
                'dog', 'doge', 'shib', 'inu', 'pepe', 'wojak', 'moon', 
                'elon', 'cat', 'kitty', 'chad', 'based', 'meme', 'frog'
            ];
            return memeKeywords.some(keyword => text.includes(keyword));
        }

        async function analyzeToken(token) {
            try {
                // Obtener datos del token desde Phantom
                const tokenData = await phantom.getTokenData(token.address);
                const priceHistory = await phantom.getTokenPriceHistory(token.address);
                const holders = await phantom.getTokenHolders(token.address);

                // Análisis de viabilidad
                const age = calculateTokenAge(priceHistory);
                const volumeAnalysis = analyzeVolume(priceHistory);
                const holderAnalysis = analyzeHolders(holders);

                const isViable = age >= MIN_AGE_HOURS &&
                               volumeAnalysis.is24hVolumeGood &&
                               volumeAnalysis.isBuyVolumeHigher &&
                               !holderAnalysis.hasRiskyHolders;

                return {
                    isViable,
                    age,
                    volume24h: volumeAnalysis.volume24h,
                    buyVolume: volumeAnalysis.buyVolume,
                    sellVolume: volumeAnalysis.sellVolume,
                    holderMetrics: holderAnalysis,
                    priceChange24h: tokenData.priceChange24h
                };
            } catch (error) {
                console.error('Error analizando token:', error);
                return null;
            }
        }

        function calculateTokenAge(priceHistory) {
            if (!priceHistory || priceHistory.length === 0) return 0;
            const firstPrice = priceHistory[0];
            const now = Date.now();
            return (now - firstPrice.timestamp) / (1000 * 60 * 60);
        }

        function analyzeVolume(priceHistory) {
            const last24h = priceHistory.filter(p => 
                p.timestamp > Date.now() - 24 * 60 * 60 * 1000
            );

            const buyVolume = last24h.reduce((sum, p) => 
                sum + (p.type === 'buy' ? p.volume : 0), 0
            );

            const sellVolume = last24h.reduce((sum, p) => 
                sum + (p.type === 'sell' ? p.volume : 0), 0
            );

            return {
                volume24h: buyVolume + sellVolume,
                buyVolume,
                sellVolume,
                is24hVolumeGood: (buyVolume + sellVolume) >= MIN_VOLUME,
                isBuyVolumeHigher: buyVolume > sellVolume
            };
        }

        function analyzeHolders(holders) {
            const totalSupply = holders.reduce((sum, h) => sum + h.amount, 0);
            const largeHolders = holders.filter(h => 
                (h.amount / totalSupply) * 100 > 5 && 
                !h.isContract
            );

            return {
                hasRiskyHolders: largeHolders.length > 2,
                topHoldersPercentage: largeHolders.reduce((sum, h) => 
                    sum + (h.amount / totalSupply) * 100, 0
                ),
                holderCount: holders.length
            };
        }

        async function executeTrade(token, action) {
            try {
                if (action === 'buy') {
                    const amount = calculateTradeAmount(token);
                    await phantom.swapTokens({
                        fromToken: 'SOL',
                        toToken: token.address,
                        amount,
                        slippage: 1 // 1% slippage
                    });

                    currentTrade = {
                        token,
                        buyPrice: token.price,
                        amount,
                        timestamp: Date.now()
                    };

                    addToTradeHistory('Compra', token, amount, token.price);
                } else if (action === 'sell') {
                    await phantom.swapTokens({
                        fromToken: token.address,
                        toToken: 'SOL',
                        amount: currentTrade.amount,
                        slippage: 1
                    });

                    const profit = ((token.price - currentTrade.buyPrice) / currentTrade.buyPrice) * 100;
                    addToTradeHistory('Venta', token, currentTrade.amount, token.price, profit);
                    currentTrade = null;
                }
            } catch (error) {
                showError(`Error en transacción: ${error.message}`);
            }
        }

        function addToTradeHistory(type, token, amount, price, profit = null) {
            const historyDiv = document.getElementById('tradeHistory');
            const tradeItem = document.createElement('div');
            tradeItem.className = 'trade-item';
            
            let profitText = '';
            if (profit !== null) {
                const profitClass = profit >= 0 ? 'profit' : 'loss';
                profitText = `<span class="${profitClass}">(${profit.toFixed(2)}%)</span>`;
            }
            
            tradeItem.innerHTML = `
                ${type}: ${token.symbol}
                Cantidad: ${amount.toFixed(2)}
                Precio: $${price.toFixed(6)}
                ${profitText}
            `;
            
            historyDiv.insertBefore(tradeItem, historyDiv.firstChild);
        }

        async function startTradingBot() {
            activeTrading = true;
            document.getElementById('status').textContent = 'Bot activo - Buscando oportunidades';
            
            while (activeTrading) {
                try {
                    if (!currentTrade) {
                        const memecoins = await getTrendingMemecoins();
                        
                        for (const token of memecoins) {
                            const analysis = await analyzeToken(token);
                            
                            if (analysis && analysis.isViable) {
                                await executeTrade(token, 'buy');
                                break;
                            }
                        }
                    } else {
                        const currentPrice = await phantom.getTokenPrice(currentTrade.token.address);
                        const priceChange = ((currentPrice - currentTrade.buyPrice) / currentTrade.buyPrice) * 100;
                        
                        if (priceChange >= PROFIT_TARGET || priceChange <= STOP_LOSS) {
                            await executeTrade(currentTrade.token, 'sell');
                        }
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 10000));
                } catch (error) {
                    console.error('Error en ciclo de trading:', error);
                    await new Promise(resolve => setTimeout(resolve, 30000));
                }
            }
        }

        // Event Listeners
        document.getElementById('connectBtn').addEventListener('click', connectPhantom);
    </script>
</body>
</html> 